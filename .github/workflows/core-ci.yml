name: core-ci

on:
  push:
  pull_request:

jobs:
  build-and-smoke:
    runs-on: windows-latest
    timeout-minutes: 45
    steps:
      - uses: actions/checkout@v4

      - name: Setup MSBuild
        uses: microsoft/setup-msbuild@v1.3.1

      - name: Build Debug
        run: msbuild D-Engine.sln /p:Configuration=Debug /p:Platform=x64 /m

      - name: Build Release
        run: msbuild D-Engine.sln /p:Configuration=Release /p:Platform=x64 /m

      - name: Build Debug (mem tracking compile-only)
        shell: pwsh
        run: |
          $defs = 'DNG_MEM_TRACKING=1%3BDNG_MEM_CAPTURE_CALLSITE=1%3B%(PreprocessorDefinitions)'
          msbuild D-Engine.vcxproj /p:Configuration=Debug /p:Platform=x64 "/p:PreprocessorDefinitions=$defs" /p:BuildProjectReferences=false

      - name: Run AllSmokes
        shell: pwsh
        run: |
          $preferred = @('.\x64\Release\AllSmokes.exe', '.\x64\Debug\AllSmokes.exe')
          $exe = $null
          foreach ($p in $preferred) {
            if (Test-Path $p) { $exe = (Resolve-Path $p).Path; break }
          }
          if (-not $exe) {
            $candidates = Get-ChildItem -Path . -Recurse -Filter 'AllSmokes*.exe' | Sort-Object @{Expression = { $_.FullName -match 'Release' } ; Descending = $true}, LastWriteTime -Descending
            if (-not $candidates) {
              Write-Error 'AllSmokes executable not found after build.'
              exit 1
            }
            Write-Host "WARNING: using fallback exe discovery: $($candidates[0].FullName)" -ForegroundColor Yellow
            $exe = $candidates[0].FullName
          }
          New-Item -ItemType Directory -Path '.\artifacts\gates' -Force | Out-Null
          $log = '.\artifacts\gates\allsmokes.log'
          Write-Host "Running $exe (log: $log)"
          & $exe 2>&1 | Tee-Object -FilePath $log
          if ($LASTEXITCODE -ne 0) {
            Write-Error "AllSmokes failed with exit code $LASTEXITCODE"
            exit $LASTEXITCODE
          }
          $leaks = Select-String -Path $log -Pattern '=== MEMORY LEAKS DETECTED ===', 'TOTAL LEAKS:' -SimpleMatch -ErrorAction SilentlyContinue
          if ($leaks) {
            Write-Error "Leak markers detected in AllSmokes log"
            exit 1
          }

      - name: Run MemoryStressSmokes
        shell: pwsh
        run: |
          $preferred = @('.\x64\Release\MemoryStressSmokes.exe', '.\x64\Debug\MemoryStressSmokes.exe')
          $exe = $null
          foreach ($p in $preferred) {
            if (Test-Path $p) { $exe = (Resolve-Path $p).Path; break }
          }
          if (-not $exe) {
            $candidates = Get-ChildItem -Path . -Recurse -Filter 'MemoryStressSmokes*.exe' | Sort-Object @{Expression = { $_.FullName -match 'Release' } ; Descending = $true}, LastWriteTime -Descending
            if (-not $candidates) {
              Write-Warning 'MemoryStressSmokes executable not found after build. Skipping step for this checkout.'
              return
            }
            Write-Host "WARNING: using fallback exe discovery: $($candidates[0].FullName)" -ForegroundColor Yellow
            $exe = $candidates[0].FullName
          }
          New-Item -ItemType Directory -Path '.\artifacts\gates' -Force | Out-Null
          $log = '.\artifacts\gates\memorystresssmokes.log'
          Write-Host "Running $exe (log: $log)"
          & $exe 2>&1 | Tee-Object -FilePath $log
          if ($LASTEXITCODE -ne 0) {
            Write-Error "MemoryStressSmokes failed with exit code $LASTEXITCODE"
            exit $LASTEXITCODE
          }
          $leaks = Select-String -Path $log -Pattern '=== MEMORY LEAKS DETECTED ===', 'TOTAL LEAKS:' -SimpleMatch -ErrorAction SilentlyContinue
          if ($leaks) {
            Write-Error "Leak markers detected in MemoryStressSmokes log"
            exit 1
          }

      - name: Run ModuleSmoke (ABI runtime smoke)
        shell: pwsh
        run: |
          $preferred = @('.\x64\Release\ModuleSmoke.exe', '.\x64\Debug\ModuleSmoke.exe')
          $exe = $null
          foreach ($p in $preferred) {
            if (Test-Path $p) { $exe = (Resolve-Path $p).Path; break }
          }
          if (-not $exe) {
            $candidates = Get-ChildItem -Path . -Recurse -Filter 'ModuleSmoke*.exe' | Sort-Object @{Expression = { $_.FullName -match 'Release' } ; Descending = $true}, LastWriteTime -Descending
            if (-not $candidates) {
              Write-Error 'ModuleSmoke executable not found after build.'
              exit 1
            }
            Write-Host "WARNING: using fallback exe discovery: $($candidates[0].FullName)" -ForegroundColor Yellow
            $exe = $candidates[0].FullName
          }

          $nullDll = Get-ChildItem -Path . -Recurse -Filter 'NullWindowModule.dll' -ErrorAction SilentlyContinue |
            Sort-Object @{Expression = { $_.FullName -match 'Release' } ; Descending = $true}, LastWriteTime -Descending |
            Select-Object -First 1
          if (-not $nullDll) {
            $cargo = Get-Command cargo -ErrorAction SilentlyContinue
            $moduleRoot = Join-Path (Get-Location) 'External/Rust/NullWindowModule'
            if ($cargo -and (Test-Path $moduleRoot)) {
              Write-Host "NullWindowModule.dll missing; attempting Rust build via cargo in $moduleRoot" -ForegroundColor Yellow
              Push-Location $moduleRoot
              try {
                & $cargo.Path build --release
                if ($LASTEXITCODE -eq 0) {
                  $built = Join-Path $moduleRoot 'target/release/rust_null_window_module.dll'
                  if (Test-Path $built) {
                    foreach ($dest in @('.\x64\Release\NullWindowModule.dll', '.\x64\Debug\NullWindowModule.dll')) {
                      $destDir = Split-Path $dest -Parent
                      if (-not (Test-Path $destDir)) { New-Item -ItemType Directory -Path $destDir -Force | Out-Null }
                      Copy-Item -Path $built -Destination $dest -Force
                    }
                  }
                }
              }
              finally {
                Pop-Location
              }
            }

            $nullDll = Get-ChildItem -Path . -Recurse -Filter 'NullWindowModule.dll' -ErrorAction SilentlyContinue |
              Sort-Object @{Expression = { $_.FullName -match 'Release' } ; Descending = $true}, LastWriteTime -Descending |
              Select-Object -First 1
            if (-not $nullDll) {
              Write-Warning 'NullWindowModule.dll not found in this CI checkout. Skipping ModuleSmoke.'
              return
            }
          }

          New-Item -ItemType Directory -Path '.\artifacts\gates' -Force | Out-Null
          $log = '.\artifacts\gates\modulesmoke.log'
          Write-Host "Running $exe (log: $log)"
          & $exe 2>&1 | Tee-Object -FilePath $log
          if ($LASTEXITCODE -ne 0) {
            Write-Error "ModuleSmoke failed with exit code $LASTEXITCODE"
            exit $LASTEXITCODE
          }
          $leaks = Select-String -Path $log -Pattern '=== MEMORY LEAKS DETECTED ===', 'TOTAL LEAKS:' -SimpleMatch -ErrorAction SilentlyContinue
          if ($leaks) {
            Write-Error "Leak markers detected in ModuleSmoke log"
            exit 1
          }
